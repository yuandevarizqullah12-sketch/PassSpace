<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>SpacePass — ISS Tracker (Red Track & Minimal UI)</title>

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
:root{
  --bg:#060618;
  --panel:#0b1020;
  --accent:#00e6ff;
  --muted:#9aa7b2;
  --danger:#ff3b3b;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0}
body{
  font-family:Inter,system-ui,Segoe UI,Roboto,Arial;
  background:
    radial-gradient(1200px 600px at 10% 10%, rgba(0,230,255,0.03), transparent 5%),
    radial-gradient(900px 400px at 90% 90%, rgba(0,120,255,0.02), transparent 10%),
    var(--bg);
  color:#eaf6ff;
  display:flex;
  gap:18px;
  padding:18px;
  align-items:stretch;
  min-height:100vh;
}

/* Left panel (aligned grid) */
.panel{
  width:380px; max-width:420px; min-width:280px;
  border-radius:12px;
  padding:16px;
  background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
  border:1px solid rgba(0,230,255,0.06);
  display:flex;flex-direction:column;gap:12px; overflow:auto;
  box-shadow:0 8px 30px rgba(0,0,0,0.6);
}

/* Custom scrollbar */
.panel::-webkit-scrollbar{ width:8px }
.panel::-webkit-scrollbar-track{ background: rgba(255,255,255,0.02); border-radius:8px }
.panel::-webkit-scrollbar-thumb{
  background: linear-gradient(180deg, rgba(0,230,255,0.9), rgba(0,120,255,0.8));
  border-radius:8px; border:2px solid rgba(0,0,0,0.25);
}
.panel{ scrollbar-width: thin; scrollbar-color: rgba(0,200,255,0.95) rgba(255,255,255,0.02) }

/* Header */
.header{ display:flex; gap:12px; align-items:center }
.logo{ width:48px;height:48px;border-radius:10px; display:flex;align-items:center;justify-content:center; background:linear-gradient(135deg,#031022,#02243a); border:1px solid rgba(0,230,255,0.12) }
h1{ margin:0; font-size:16px; color:var(--accent) }
.lead{ margin:0; color:var(--muted); font-size:13px }

/* Search */
.search-row{ display:flex; gap:8px; align-items:center; margin-top:6px; }
.search-input{ flex:1; padding:8px 10px; border-radius:8px; background:rgba(0,0,0,0.06); border:1px solid rgba(255,255,255,0.03); color:#eaf6ff; }
.search-results{ position:relative; }
.results-list{ position:relative; max-height:180px; overflow:auto; margin-top:6px; background:rgba(0,0,0,0.06); border-radius:8px; border:1px solid rgba(255,255,255,0.02); }
.result-item{ padding:8px 10px; cursor:pointer; border-bottom:1px solid rgba(255,255,255,0.02); color:#eaf6ff; }
.result-item:hover{ background: rgba(255,255,255,0.02); }

/* Position grid: 2-column aligned */
.pos-grid{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:10px;
  align-items:start;
}
.stat{
  background: rgba(255,255,255,0.02);
  padding:10px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.02);
}
.stat .label{ color:var(--muted); font-size:13px; }
.stat .value{ color:#fff; font-weight:700; font-size:16px; margin-top:6px; }

/* Next pass card */
.pass-card{ background: rgba(0,0,0,0.06); padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.02) }
.pass-row{ display:flex; justify-content:space-between; gap:8px; padding:6px 0; align-items:center; }
.pass-label{ color:var(--muted); font-size:13px }
.pass-value{ color:#fff; font-weight:700; text-align:right }

/* Small UI */
.small-muted{ color:var(--muted); font-size:13px }
.btn{ background:transparent; border:1px solid rgba(255,255,255,0.04); padding:8px 10px; border-radius:8px; color:#e8fbff; cursor:pointer }
.btn.primary{ background:linear-gradient(90deg,var(--accent),#0078ff); color:#001; border:none }

/* Map */
.map-wrap{ flex:1; border-radius:12px; overflow:hidden; display:flex; flex-direction:column; border:1px solid rgba(255,255,255,0.03) }
#map{ flex:1; min-height:420px }
.map-footer{ padding:10px 14px; display:flex; justify-content:space-between; align-items:center; gap:12px; background:rgba(0,0,0,0.08); border-top:1px solid rgba(255,255,255,0.02) }

/* disclaimer */
.disclaimer{ font-size:12px; color:#cfdfe6; margin-top:8px; opacity:0.9; }

/* responsive */
@media (max-width:900px){
  body{ flex-direction:column; padding:12px }
  .panel{ width:100%; max-height:45vh }
  .map-wrap{ width:100%; min-height:320px }
}
</style>
</head>
<body>

<aside class="panel" aria-label="Controls (minimal)">
  <div class="header">
    <div class="logo" title="SpacePass">
      <svg width="36" height="36" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
        <rect x="6" y="18" width="52" height="28" rx="6" fill="#001a21"/>
        <path d="M10 24h44" stroke="#00e6ff" stroke-width="1.2" stroke-linecap="round"/>
        <circle cx="32" cy="32" r="4" fill="#00e6ff"/>
      </svg>
    </div>
    <div>
      <h1>SpacePass — ISS</h1>
      <p class="lead">Posisi & lintasan — API → TLE → fallback</p>
    </div>
  </div>

  <div><div class="small-muted">Sumber:</div><div id="sourceStatus" class="small-muted">mengecek…</div></div>

  <!-- SEARCH: place / device -->
  <div class="search-row">
    <input id="searchInput" class="search-input" placeholder="Search country/city (e.g. Indonesia, Jakarta)" />
    <button id="myLocBtn" class="btn" title="Use device location">My loc</button>
  </div>
  <div class="search-results" id="searchResults" style="display:none"></div>

  <div class="pos-grid" aria-hidden="false">
    <div class="stat">
      <div class="label">Latitude</div>
      <div class="value" id="lat">—</div>
    </div>
    <div class="stat">
      <div class="label">Longitude</div>
      <div class="value" id="lon">—</div>
    </div>

    <div class="stat">
      <div class="label">Altitude (km)</div>
      <div class="value" id="alt">—</div>
    </div>
    <div class="stat">
      <div class="label">Velocity (km/h)</div>
      <div class="value" id="spd">—</div>
    </div>

    <div class="stat">
      <div class="label">Ground speed</div>
      <div class="value" id="groundSpeed">—</div>
    </div>
    <div class="stat">
      <div class="label">Typical alt</div>
      <div class="value" id="typAlt">~408 km</div>
    </div>
  </div>

  <div class="pass-card">
    <div style="font-size:13px;color:var(--muted);margin-bottom:6px">Lewat (Sebelumnya / Sekarang / Berikutnya) — berdasarkan lokasi pencarian</div>

    <div class="pass-row">
      <div class="pass-label">Sebelumnya</div>
      <div class="pass-value" id="prevPlace">—</div>
    </div>

    <div class="pass-row">
      <div class="pass-label">Sekarang</div>
      <div class="pass-value" id="nowPlace">—</div>
    </div>

    <div class="pass-row">
      <div class="pass-label">Berikutnya</div>
      <div class="pass-value" id="nextPlace">—</div>
    </div>
  </div>

  <div style="display:flex;gap:8px;align-items:center">
    <button id="centerBtn" class="btn">Center ke ISS</button>
    <button id="clearTrack" class="btn">Clear Track</button>
  </div>

  <div class="small-muted">Titik terekam: <span id="pointsCount">0</span></div>

  <div class="disclaimer" id="disclaimer">
    Data posisi: wheretheiss.at (API) dan TLE lokal (Celestrak). Untuk laut teritorial dipakai MarineRegions (jika tersedia). Kami tidak bertanggung jawab atas kesalahan posisi. Hanya untuk tujuan edukasi.
  </div>
</aside>

<main class="map-wrap">
  <div id="map"></div>
  <div class="map-footer">
    <div id="mapStatus" class="small-muted">memuat peta…</div>
    <div class="small-muted">Polling tiap 5s • fallback: TLE/local • EEZ: MarineRegions</div>
  </div>
</main>

<!-- Leaflet & satellite.js -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/satellite.js/dist/satellite.min.js"></script>

<script>
/*
  SpacePass — final merged: search + red past line only
  - Removed future yellow line (user requested)
  - Search (Nominatim) autocomplete + compute pass near searched point (±55m)
  - Keeps TLE caching/propagation, API fallback, stored track, and avoids abstract jumps
*/

// ---- CONFIG ----
const POLL_MS = 5000;
const MAX_POINTS = 2000;
const JUMP_KM_THRESHOLD = 1000;
const CELESTRAK_URL = 'https://celestrak.com/NORAD/elements/stations.txt';
const MARINEREGIONS_EEZ_ENDPOINT = 'https://www.marineregions.org/rest/getGazetteerRecordsByLatLong.json';
const SHADOW_INTERVAL_SEC = 60;
const PAST_DURATION_SEC = 55 * 60;
// FUTURE_DURATION_SEC still used for pass detection window (search), but we won't draw future line
const FUTURE_DURATION_SEC = 55 * 60;

// ---- state & ui refs ----
let USING = { tilesLocal:false, posAPI:false, tleLoaded:false, tleUsed:false };
let tleLines = null;
let tleCachedAt = null;
let lastSourceWasAPI = null;

const latEl = document.getElementById('lat');
const lonEl = document.getElementById('lon');
const altEl = document.getElementById('alt');
const spdEl = document.getElementById('spd');
const groundEl = document.getElementById('groundSpeed');
const typAltEl = document.getElementById('typAlt');
const prevPlaceEl = document.getElementById('prevPlace');
const nowPlaceEl = document.getElementById('nowPlace');
const nextPlaceEl = document.getElementById('nextPlace');
const sourceStatus = document.getElementById('sourceStatus');
const mapStatus = document.getElementById('mapStatus');
const pointsCountEl = document.getElementById('pointsCount');
const centerBtn = document.getElementById('centerBtn');
const clearTrackBtn = document.getElementById('clearTrack');

const searchInput = document.getElementById('searchInput');
const searchResults = document.getElementById('searchResults');
const myLocBtn = document.getElementById('myLocBtn');

// ---- map init ----
const map = L.map('map', { zoomControl:true }).setView([0,0], 2);

async function testLocalTile(){
  try{
    const r = await fetch('tiles/2/1/1.png', { method:'HEAD' }).catch(()=>null);
    return r && r.ok;
  }catch(e){ return false; }
}
async function initTiles(){
  const ok = await testLocalTile();
  USING.tilesLocal = !!ok;
  if(ok){
    L.tileLayer('tiles/{z}/{x}/{y}.png', { minZoom:0, maxZoom:6, attribution:'Offline tiles' }).addTo(map);
    mapStatus.textContent = 'Menggunakan tiles lokal.';
  } else {
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom:19, attribution:'&copy; OSM' }).addTo(map);
    mapStatus.textContent = 'Menggunakan tiles online.';
  }
  updateSourceLabel();
}
initTiles();

// ---- icons / lines ----
const mainIcon = L.divIcon({
  html: `<svg width="48" height="48" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><g><circle cx="32" cy="32" r="18" fill="#ff3b3b" opacity="0.14"/><path d="M20 32h24" stroke="#ff3b3b" stroke-width="2.4" stroke-linecap="round"/></g></svg>`,
  className:'', iconSize:[48,48], iconAnchor:[24,24]
});
const issMarker = L.marker([0,0], { icon: mainIcon }).addTo(map);

// Continuous past polyline only (red)
let pastLine = L.polyline([], { color:'#ff3b3b', weight:4, opacity:0.95 }).addTo(map);

let onlineSegments = [];
let offlineSegments = [];
let onlinePoints = [];
let offlinePoints = [];

// helpers
function nowUnix(){ return Math.floor(Date.now()/1000); }
function haversine(lat1,lon1,lat2,lon2){
  const R=6371; const toRad=Math.PI/180;
  const dLat=(lat2-lat1)*toRad, dLon=(lon2-lon1)*toRad;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*toRad)*Math.cos(lat2*toRad)*Math.sin(dLon/2)**2;
  const c = 2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R*c;
}
function normalizeLon(lastLon, newLon){
  if(lastLon === null || lastLon === undefined) return ((newLon+180)%360+360)%360 - 180;
  let n = newLon;
  while(n - lastLon > 180) n -= 360;
  while(n - lastLon < -180) n += 360;
  n = ((n+180)%360+360)%360 - 180;
  return n;
}

// ---- TLE fetch/cache ----
const TLE_STORE = 'spacepass_tle_v1';
const TLE_STORE_AT = 'spacepass_tle_at';
const TRACK_KEY = 'spacepass_iss_track_v6';

async function fetchAndCacheTLE(){
  try{
    const r = await fetch(CELESTRAK_URL).catch(()=>null);
    if(!r || !r.ok) return false;
    const txt = await r.text();
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    for(let i=0;i<lines.length;i++){
      if(/ISS\s*\(|ISS\s*ZARYA|ISS \(ZARYA\)/i.test(lines[i]) || lines[i].toUpperCase().includes('ISS')){
        if(i+2 < lines.length){
          const l1 = lines[i+1], l2 = lines[i+2];
          tleLines = [l1, l2];
          tleCachedAt = Date.now();
          localStorage.setItem(TLE_STORE, JSON.stringify(tleLines));
          localStorage.setItem(TLE_STORE_AT, String(tleCachedAt));
          USING.tleLoaded = true;
          USING.tleUsed = !!(window.satellite && tleLines);
          updateSourceLabel();
          return true;
        }
      }
    }
    return false;
  }catch(e){ return false; }
}
function loadCachedTLE(){
  try{
    const raw = localStorage.getItem(TLE_STORE);
    const at = localStorage.getItem(TLE_STORE_AT);
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr) && arr.length === 2){
        tleLines = arr;
        tleCachedAt = at ? Number(at) : null;
        USING.tleLoaded = true;
        USING.tleUsed = !!(window.satellite && tleLines);
      }
    }
  }catch(e){}
}
loadCachedTLE();
fetchAndCacheTLE().catch(()=>{});

// ---- propagate using TLE ----
function posFromTLEAtDate(date){
  try{
    if(!(tleLines && window.satellite)) return null;
    const satrec = satellite.twoline2satrec(tleLines[0], tleLines[1]);
    const eci = satellite.propagate(satrec, date);
    if(!eci || !eci.position) return null;
    const gmst = satellite.gstime(date);
    const geo = satellite.eciToGeodetic(eci.position, gmst);
    const lat = satellite.degreesLat(geo.latitude);
    const lon = satellite.degreesLong(geo.longitude);
    const alt = geo.height;
    return { latitude: lat, longitude: lon, altitude: alt, velocity: null, timestamp: Math.floor(date.getTime()/1000), source:'TLE' };
  }catch(e){ return null; }
}

// ---- API fetch ----
async function fetchFromAPI(){
  try{
    const r = await fetch('https://api.wheretheiss.at/v1/satellites/25544');
    if(!r.ok) throw new Error('api fail');
    const j = await r.json();
    return {
      latitude: Number(j.latitude),
      longitude: Number(j.longitude),
      altitude: j.altitude !== undefined ? Number(j.altitude) : null,
      velocity: j.velocity !== undefined ? Number(j.velocity) : null,
      timestamp: Number(j.timestamp) || nowUnix(),
      source:'API'
    };
  }catch(e){ return null; }
}
function samplePos(){
  return {latitude:0,longitude:0,altitude:408,velocity:27600, timestamp: nowUnix(), source:'sample'};
}

// ---- main getPosition (API -> TLE -> sample) ----
async function getPosition(){
  const api = await fetchFromAPI();
  if(api){
    fetchAndCacheTLE().catch(()=>{});
    USING.posAPI = true;
    return api;
  }
  USING.posAPI = false;
  if(tleLines && window.satellite){
    const tpos = posFromTLEAtDate(new Date());
    if(tpos) return tpos;
  }
  return samplePos();
}

// ---- track storage & rebuild ----
function saveTrack(){
  try{
    const merged = onlinePoints.concat(offlinePoints);
    merged.sort((a,b)=> (a.timestamp||0) - (b.timestamp||0));
    localStorage.setItem(TRACK_KEY, JSON.stringify(merged.slice(-MAX_POINTS)));
  }catch(e){ console.warn('saveTrack', e); }
}
function loadTrack(){
  try{
    const raw = localStorage.getItem(TRACK_KEY);
    if(!raw) return;
    const arr = JSON.parse(raw);
    arr.forEach(pt=>{
      if(pt.source === 'API') onlinePoints.push(pt);
      else offlinePoints.push(pt);
    });
    rebuildPolylinesFromPoints();
    pointsCountEl.textContent = onlinePoints.length + offlinePoints.length;
  }catch(e){ console.warn('loadTrack', e); }
}
function rebuildPolylinesFromPoints(){
  onlineSegments.forEach(s=>map.removeLayer(s));
  offlineSegments.forEach(s=>map.removeLayer(s));
  onlineSegments = []; offlineSegments = [];
  function splitAndCreate(arr, createFn){
    let seg = [];
    let last = null;
    arr.forEach(p=>{
      if(last){
        const d = haversine(last.latitude,last.longitude,p.latitude,p.longitude);
        if(d > JUMP_KM_THRESHOLD){
          if(seg.length) createFn(seg);
          seg = [];
        }
      }
      seg.push([p.latitude, p.longitude]);
      last = p;
    });
    if(seg.length) createFn(seg);
  }
  splitAndCreate(onlinePoints, coords => createOnlineSegment(coords));
  splitAndCreate(offlinePoints, coords => createOfflineSegment(coords));
}
function createOnlineSegment(coords){
  const seg = L.polyline(coords, { color:'#ff3b3b', weight:3, opacity:0.85 }).addTo(map);
  onlineSegments.push(seg);
  return seg;
}
function createOfflineSegment(coords){
  const seg = L.polyline(coords, { color:'#ff7b7b', weight:2.6, opacity:0.6, dashArray:'6 8' }).addTo(map);
  offlineSegments.push(seg);
  return seg;
}

// ---- addPointSmart (preserve behavior) ----
function addPointSmart(pos){
  pos = Object.assign({}, pos);
  pos.timestamp = pos.timestamp || nowUnix();
  const isAPI = pos.source === 'API';

  if(lastSourceWasAPI === true && !isAPI){
    // separation handled below
  }
  lastSourceWasAPI = isAPI;

  const arr = isAPI ? onlinePoints : offlinePoints;
  const segs = isAPI ? onlineSegments : offlineSegments;
  const lastSame = arr.length ? arr[arr.length-1] : null;

  if(lastSame){
    const d = haversine(lastSame.latitude,lastSame.longitude,pos.latitude,pos.longitude);
    if(d > JUMP_KM_THRESHOLD){
      if(isAPI) createOnlineSegment([[pos.latitude,pos.longitude]]);
      else createOfflineSegment([[pos.latitude,pos.longitude]]);
      arr.push(pos);
      truncatePointsIfNeeded();
      saveTrack();
      pointsCountEl.textContent = onlinePoints.length + offlinePoints.length;
      updateUIFromPos(pos);
      updatePastLine();
      return;
    }
  } else {
    if(isAPI) createOnlineSegment([[pos.latitude,pos.longitude]]);
    else createOfflineSegment([[pos.latitude,pos.longitude]]);
    arr.push(pos);
    truncatePointsIfNeeded();
    saveTrack();
    pointsCountEl.textContent = onlinePoints.length + offlinePoints.length;
    updateUIFromPos(pos);
    updatePastLine();
    return;
  }

  const seg = segs.length ? segs[segs.length-1] : null;
  if(!seg){
    if(isAPI) createOnlineSegment([[pos.latitude,pos.longitude]]);
    else createOfflineSegment([[pos.latitude,pos.longitude]]);
  } else {
    const latlngs = seg.getLatLngs ? seg.getLatLngs() : [];
    const lastLon = latlngs.length ? latlngs[latlngs.length-1].lng : null;
    const adjLon = normalizeLon(lastLon, pos.longitude);
    seg.addLatLng([pos.latitude, adjLon]);
    pos.longitude = adjLon;
  }

  arr.push(pos);
  truncatePointsIfNeeded();
  saveTrack();
  pointsCountEl.textContent = onlinePoints.length + offlinePoints.length;
  updateUIFromPos(pos);
  updatePastLine();
}

function truncatePointsIfNeeded(){
  while(onlinePoints.length + offlinePoints.length > MAX_POINTS){
    if(offlinePoints.length) offlinePoints.shift();
    else onlinePoints.shift();
  }
}

// ---- UI updates ----
function updateUIFromPos(p){
  latEl.textContent = p.latitude.toFixed(5);
  lonEl.textContent = p.longitude.toFixed(5);
  altEl.textContent = p.altitude !== null ? p.altitude.toFixed(2) : '—';
  spdEl.textContent = p.velocity !== null ? p.velocity.toFixed(2) : '—';
  typAltEl.textContent = p.altitude ? Math.round(p.altitude) + ' km' : '~408 km';
  const all = onlinePoints.concat(offlinePoints).sort((a,b)=> (a.timestamp||0)-(b.timestamp||0));
  const last = all[all.length-1];
  const prev = all.length>1 ? all[all.length-2] : null;
  if(prev && last){
    const d = haversine(prev.latitude, prev.longitude, last.latitude, last.longitude);
    const dt = last.timestamp - prev.timestamp;
    const kmh = dt>0 ? (d/dt)*3600 : null;
    groundEl.textContent = kmh ? kmh.toFixed(2) + ' km/h' : '—';
  } else {
    groundEl.textContent = '—';
  }
  try{ issMarker.setLatLng([p.latitude, p.longitude]); }catch(e){}
}

// ---- reverse place (MarineRegions -> Nominatim) ----
const _rg_cache = new Map();
async function lookupMarineRegions(lat, lon){
  try{
    const url = `${MARINEREGIONS_EEZ_ENDPOINT}/${encodeURIComponent(lat)}/${encodeURIComponent(lon)}`;
    const r = await fetch(url).catch(()=>null);
    if(!r || !r.ok) throw new Error('mr fail');
    const j = await r.json();
    if(!Array.isArray(j) || j.length === 0) throw new Error('mr empty');
    for(const item of j){
      if(item && (item.name || item.title || item.preferredGazetteerName)){
        const nm = item.preferredGazetteerName || item.title || item.name;
        if(item.sovereign) return `${nm} (EEZ: ${item.sovereign})`;
        if(item.sovereignname) return `${nm} (EEZ: ${item.sovereignname})`;
        return String(nm);
      }
    }
    return j[0].preferredGazetteerName || j[0].title || j[0].name || null;
  }catch(e){ return null; }
}
async function reversePlace(lat, lon){
  const key = `${lat.toFixed(4)},${lon.toFixed(4)}`;
  if(_rg_cache.has(key)) return _rg_cache.get(key);
  const mr = await lookupMarineRegions(lat, lon);
  if(mr){ _rg_cache.set(key, mr); return mr; }
  try{
    const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}`;
    const r = await fetch(url, { headers:{ 'User-Agent':'SpacePass-ISS-Tracker/1.0 (test)' } }).catch(()=>null);
    if(!r || !r.ok) throw new Error('nom fail');
    const j = await r.json();
    const name = j.address && (j.address.city || j.address.town || j.address.village || j.address.state || j.address.country);
    let result = 'Unknown location';
    if(name && j.address && j.address.country){
      if(name === j.address.country) result = j.address.country;
      else result = `${name}, ${j.address.country}`;
    } else if(name) result = name;
    else if(j.display_name) result = j.display_name.split(',')[0];
    _rg_cache.set(key, result);
    return result;
  }catch(e){ _rg_cache.set(key, 'Unknown location'); return 'Unknown location'; }
}

// ---- update pass info for panel (prev, now, next) ----
async function updatePassInfo(){
  const all = onlinePoints.concat(offlinePoints).sort((a,b)=> (a.timestamp||0)-(b.timestamp||0));
  const n = all.length;
  const now = n ? all[n-1] : null;
  const prev = n>1 ? all[n-2] : null;
  let next = null;
  if(prev && now){
    const dt = now.timestamp - prev.timestamp;
    if(dt > 0){
      const dLat = (now.latitude - prev.latitude)/dt;
      const dLon = (now.longitude - prev.longitude)/dt;
      const predictSec = 90;
      next = { latitude: now.latitude + dLat * predictSec, longitude: now.longitude + dLon * predictSec, timestamp: now.timestamp + predictSec };
    }
  } else if(now){
    next = { latitude: now.latitude + 0.1, longitude: now.longitude + 0.1, timestamp: now.timestamp + 90 };
  }

  prevPlaceEl.textContent = '—'; nowPlaceEl.textContent='—'; nextPlaceEl.textContent='—';
  if(prev) reversePlace(prev.latitude, prev.longitude).then(name=> prevPlaceEl.textContent = name);
  if(now) reversePlace(now.latitude, now.longitude).then(name=> nowPlaceEl.textContent = name);
  if(next) reversePlace(next.latitude, next.longitude).then(name=> nextPlaceEl.textContent = name);
}

// ---- build continuous past polyline (±55m past only) ----
function getNearestTrackPositionAt(unixSec){
  const all = onlinePoints.concat(offlinePoints);
  if(!all.length) return null;
  let best = null, bestDiff = Infinity;
  for(const p of all){
    const d = Math.abs((p.timestamp||0) - unixSec);
    if(d < bestDiff){
      bestDiff = d; best = p;
    }
  }
  if(best && bestDiff <= SHADOW_INTERVAL_SEC + 30) return best;
  return null;
}
function propagateUsingTLEAt(unixSec){
  if(!(tleLines && window.satellite)) return null;
  const date = new Date(unixSec*1000);
  return posFromTLEAtDate(date);
}

async function buildPastPolylinePoints(){
  const now = nowUnix();
  const start = now - PAST_DURATION_SEC;
  const pts = [];
  for(let t = start; t <= now; t += SHADOW_INTERVAL_SEC){
    const trackPos = getNearestTrackPositionAt(t);
    if(trackPos){ pts.push([trackPos.latitude, trackPos.longitude, trackPos.timestamp]); continue; }
    const tlePos = propagateUsingTLEAt(t);
    if(tlePos){ pts.push([tlePos.latitude, tlePos.longitude, tlePos.timestamp]); continue; }
  }
  return pts;
}

function normalizePolylineCoordsForWrap(poly){
  if(!poly || poly.length === 0) return poly;
  const out = [];
  let lastLon = null;
  for(const p of poly){
    let lat = p[0], lon = p[1];
    if(lastLon === null) {
      lon = ((lon+180)%360+360)%360 - 180;
    } else {
      lon = normalizeLon(lastLon, lon);
    }
    out.push([lat, lon]);
    lastLon = lon;
  }
  return out;
}

async function updatePastLine(){
  try{
    const pastPts = await buildPastPolylinePoints();
    const pastCoords = normalizePolylineCoordsForWrap(pastPts);
    pastLine.setLatLngs(pastCoords.map(p=>[p[0], p[1]]));
  }catch(e){}
}

// ---- source label update ----
function updateSourceLabel(){
  const parts = [];
  parts.push(USING.tilesLocal ? 'tiles: lokal' : 'tiles: online');
  parts.push(USING.posAPI ? 'pos: API' : (USING.tleLoaded ? 'pos: TLE/fallback' : 'pos: sample'));
  if(tleCachedAt) {
    const ageMin = Math.round((Date.now() - tleCachedAt)/60000);
    parts.push(`TLE ${ageMin} min`);
  }
  sourceStatus.textContent = parts.join(' • ');
}

// ---- controls ----
clearTrackBtn.addEventListener('click', ()=>{ if(!confirm('Clear recorded track?')) return; onlinePoints=[]; offlinePoints=[]; onlineSegments.forEach(s=>map.removeLayer(s)); offlineSegments.forEach(s=>map.removeLayer(s)); onlineSegments=[]; offlineSegments=[]; pointsCountEl.textContent=0; saveTrack(); pastLine.setLatLngs([]); });
centerBtn.addEventListener('click', ()=>{ const all = onlinePoints.concat(offlinePoints).sort((a,b)=> (a.timestamp||0)-(b.timestamp||0)); if(all.length){ const p = all[all.length-1]; map.setView([p.latitude,p.longitude],4); }});

// ---- main polling ----
async function tick(){
  const pos = await getPosition();
  pos.timestamp = pos.timestamp || nowUnix();

  if(lastSourceWasAPI === false && pos.source === 'API'){
    if(offlinePoints.length){
      const lastOffline = offlinePoints[offlinePoints.length-1];
      const d = haversine(lastOffline.latitude,lastOffline.longitude,pos.latitude,pos.longitude);
      if(d > JUMP_KM_THRESHOLD){
        offlineSegments.forEach(s=>map.removeLayer(s));
        offlineSegments = [];
        offlinePoints = [];
      }
    }
  }

  addPointSmart(pos);
  updatePassInfo();
  updateSourceLabel();

  updatePastLine().catch(()=>{});
  try{ if(map && pos) map.panTo([pos.latitude,pos.longitude], { animate:true, duration:0.6 }); }catch(e){}
}

// ---- initial view & load track ----
(async ()=>{
  try{
    const r = await fetch('https://api.wheretheiss.at/v1/satellites/25544').catch(()=>null);
    if(r && r.ok){
      const j = await r.json();
      map.setView([j.latitude,j.longitude], 3);
    } else {
      const raw = localStorage.getItem(TRACK_KEY);
      if(raw){
        const arr = JSON.parse(raw);
        if(arr.length){
          const p = arr[arr.length-1];
          map.setView([p.latitude, p.longitude], 3);
        }
      }
    }
  }catch(e){}
})();

loadTrack();
setInterval(tick, POLL_MS);
tick();

// ---- SEARCH: Nominatim autocomplete & pass detection ----
let searchTimer = null;
searchInput.addEventListener('input', (e)=>{
  const q = e.target.value.trim();
  if(searchTimer) clearTimeout(searchTimer);
  if(!q){
    searchResults.style.display = 'none';
    searchResults.innerHTML = '';
    return;
  }
  // debounce
  searchTimer = setTimeout(()=> doSearch(q), 300);
});

async function doSearch(q){
  try{
    const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(q)}&limit=8&accept-language=en`;
    const r = await fetch(url).catch(()=>null);
    if(!r || !r.ok){ throw new Error('no'); }
    const j = await r.json();
    renderSearchResults(j || []);
  }catch(e){
    renderSearchResults([]);
  }
}
function renderSearchResults(items){
  searchResults.innerHTML = '';
  if(!items || items.length === 0){
    searchResults.style.display = 'none';
    return;
  }
  const container = document.createElement('div');
  container.className = 'results-list';
  items.forEach(it=>{
    const name = it.display_name || `${it.lat},${it.lon}`;
    const div = document.createElement('div');
    div.className = 'result-item';
    div.textContent = name;
    div.addEventListener('click', ()=>{
      const lat = parseFloat(it.lat), lon = parseFloat(it.lon);
      searchResults.style.display = 'none';
      searchResults.innerHTML = '';
      searchInput.value = name.split(',')[0];
      onPlaceSelected(lat, lon, name);
    });
    container.appendChild(div);
  });
  searchResults.appendChild(container);
  searchResults.style.display = 'block';
}

// use device location
myLocBtn.addEventListener('click', ()=>{
  if(!navigator.geolocation){ alert('Geolocation not available'); return; }
  navigator.geolocation.getCurrentPosition(pos=>{
    const lat = pos.coords.latitude, lon = pos.coords.longitude;
    onPlaceSelected(lat, lon, 'My location');
  }, err=>{
    alert('Could not get location: ' + (err.message || err.code));
  }, { enableHighAccuracy:true, maximumAge:60000, timeout:10000 });
});

// when user selects a place: center map & compute pass info for that place
async function onPlaceSelected(lat, lon, name){
  map.setView([lat, lon], 5);
  const res = await computePassTimesForLocation(lat, lon);
  prevPlaceEl.textContent = res.prev ? (new Date(res.prev.t*1000).toLocaleString() + ' — ' + formatDist(res.prev.dist)) : '—';
  nowPlaceEl.textContent = res.now ? (new Date(res.now.t*1000).toLocaleString() + ' — ' + formatDist(res.now.dist)) : '—';
  nextPlaceEl.textContent = res.next ? (new Date(res.next.t*1000).toLocaleString() + ' — ' + formatDist(res.next.dist)) : '—';
}

// helper format distance
function formatDist(km){
  if(km === null || km === undefined) return '';
  if(km < 1) return (km*1000).toFixed(0) + ' m';
  return km.toFixed(1) + ' km';
}

// compute pass times by sampling ±55 minutes at SHADOW_INTERVAL_SEC intervals
async function computePassTimesForLocation(lat, lon){
  const now = nowUnix();
  const start = now - PAST_DURATION_SEC;
  const end = now + FUTURE_DURATION_SEC;
  const cand = [];
  for(let t = start; t <= end; t += SHADOW_INTERVAL_SEC){
    const pos = await getPositionAtUnix(t);
    if(!pos) continue;
    const d = haversine(lat, lon, pos.latitude, pos.longitude);
    cand.push({ t, dist: d, source: pos.source });
  }
  if(cand.length === 0) return { prev:null, now:null, next:null };

  let bestPrev = null, bestNext = null, bestNow = null;
  for(const c of cand){
    if(c.t < now){
      if(!bestPrev || c.dist < bestPrev.dist) bestPrev = c;
    } else if(c.t > now){
      if(!bestNext || c.dist < bestNext.dist) bestNext = c;
    } else {
      if(!bestNow || c.dist < bestNow.dist) bestNow = c;
    }
  }
  for(const c of cand){
    if(Math.abs(c.t - now) <= SHADOW_INTERVAL_SEC){
      if(!bestNow || c.dist < bestNow.dist) bestNow = c;
    }
  }
  return { prev: bestPrev, now: bestNow, next: bestNext };
}

// get satellite subpoint at unix time (try TLE propagation else nearest recorded track interpolation)
async function getPositionAtUnix(unixSec){
  if(tleLines && window.satellite){
    const p = propagateUsingTLEAt(unixSec);
    if(p) return p;
  }
  const all = onlinePoints.concat(offlinePoints).sort((a,b)=> (a.timestamp||0)-(b.timestamp||0));
  if(all.length === 0) return null;
  let best = null, bestDiff = Infinity;
  for(const pt of all){
    const d = Math.abs((pt.timestamp||0) - unixSec);
    if(d < bestDiff){ bestDiff = d; best = pt; }
  }
  if(best && bestDiff <= SHADOW_INTERVAL_SEC + 30) return best;
  if(all.length >= 2){
    const a = all[all.length-2], b = all[all.length-1];
    const dt = (b.timestamp - a.timestamp) || 1;
    const ratio = (unixSec - b.timestamp) / dt;
    const lat = b.latitude + (b.latitude - a.latitude) * ratio;
    const lon = b.longitude + (b.longitude - a.longitude) * ratio;
    return { latitude: lat, longitude: lon, altitude: b.altitude || null, velocity: b.velocity || null, timestamp: unixSec, source:'predict' };
  }
  return null;
}

// ---- Search UX: hide results when clicking outside ----
document.addEventListener('click', (ev)=>{
  if(!searchResults.contains(ev.target) && ev.target !== searchInput){
    searchResults.style.display = 'none';
  }
});

// ---- finish ----
</script>
</body>
</html>
